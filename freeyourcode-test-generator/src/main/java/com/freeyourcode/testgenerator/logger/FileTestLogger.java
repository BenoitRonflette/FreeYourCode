package com.freeyourcode.testgenerator.logger;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.google.common.base.Preconditions;

public class FileTestLogger extends TestGeneratorLogger {

	private static final String GENERATED_FILE_PATH = "file";
	private static final String GENERATED_FILE_PACKAGE = "package";
	private static final String FULL_INJECTION = "fullInjection";
	private static final String COMMENT = "comment";

	private final static Log log = LogFactory.getLog(FileTestLogger.class);
	private final static SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");

	private final List<String[]> generatedTests = new ArrayList<String[]>();
	private final Set<Class<?>> importedClasses = new LinkedHashSet<Class<?>>();
	private final Set<Class<?>> testedClasses = new LinkedHashSet<Class<?>>();
	private final Map<String, Set<String>> declaratedFields = new LinkedHashMap<String, Set<String>>();

	public FileTestLogger(Properties props) {
		super(props);

		// If full injection is not set
		props.setProperty(FULL_INJECTION, props.getProperty(FULL_INJECTION, "false"));
		props.setProperty(COMMENT, props.getProperty(COMMENT, ""));
	}

	@Override
	public void onGenerationSuccess(String... codeLines) {
		generatedTests.add(codeLines);
	}

	@Override
	public void onGenerationFail(String msg, Exception e) {
		log.error(msg, e);
		generatedTests.add(new String[] { "//ERROR: Test generation failure caused by error: " + msg });
	}

	@Override
	public void startKilling() {
		// TODO Start killing is clearing the logger but we should begin to listen the code only when start has been called to improve
		// performance (stop listening to code when stop is called or if start has never been called).
		generatedTests.clear();
		importedClasses.clear();
		testedClasses.clear();
		declaratedFields.clear();
	}

	@Override
	public void stopKilling() {
		try {
			writeFile();
		} catch (Exception e) {
			log.error(e.getMessage());
			e.printStackTrace();
		}
	}

	private void writeFile() throws IOException {
		String filePath = Preconditions.checkNotNull(props.getProperty(GENERATED_FILE_PATH), "Generated file path (tag 'file') is required for a file logger");
		String packageName = Preconditions.checkNotNull(props.getProperty(GENERATED_FILE_PACKAGE), "Generated file package (tag 'package') is required for a file logger");
		boolean fullInjection = Boolean.parseBoolean(props.getProperty(FULL_INJECTION, "false"));

		File file = new File(filePath);
		file.delete();
		file.createNewFile();
		String fileName = file.getName();
		String className = fileName.substring(0, fileName.lastIndexOf("."));
		PrintWriter writer = new PrintWriter(filePath, "UTF-8");
		writer.println("package " + packageName + ";\n");
		writer.println("import org.mockito.InjectMocks;");
		writer.println("import org.mockito.Mock;");
		writer.println("import org.mockito.Spy;");
		writer.println("import org.mockito.Mockito;");
		writer.println("import org.powermock.api.mockito.PowerMockito;");
		writer.println("import org.powermock.core.classloader.annotations.PrepareForTest;");
		writer.println("import org.testng.annotations.Test;\n");
		writer.println("import com.freeyourcode.test.utils.GeneratedTestCase;");
		writer.println("import com.freeyourcode.prettyjson.JsonSerialisationUtils;");

		for (Class<?> usedClass : importedClasses) {
			writer.println("import " + usedClass.getName().replace("$", ".") + ";");
		}
		writer.println("");
		writer.println("/**");

		String comment = props.getProperty(COMMENT, "");
		if (StringUtils.isEmpty(comment)) {
			comment = "Test generated by a FreeYourCode agent at " + format.format(new Date(System.currentTimeMillis()));
		}
		writer.println("* " + comment);
		writer.println("*/");
		writer.print("@PrepareForTest({");
		boolean first = true;
		for (Class<?> usedClass : testedClasses) {
			if (!first) {
				writer.print(", ");
			} else {
				first = false;
			}
			writer.print(usedClass.getSimpleName() + ".class");
		}
		writer.println("})");
		writer.println("public class " + className + " extends GeneratedTestCase {");
		writer.println("");
		for (Entry<String, Set<String>> declaratedField : declaratedFields.entrySet()) {
			boolean firstAnnotation = true;
			for (String annotation : declaratedField.getValue()) {
				writer.print((firstAnnotation ? "\t" : " ") + annotation);
				firstAnnotation = false;
			}
			writer.println("");
			writer.print("\tprivate " + declaratedField.getKey());
			if (declaratedField.getValue().contains("@Spy")) {
				// TODO c'est idiot de défiare une concaténation déjà faite...
				writer.print(" = new " + declaratedField.getKey().substring(0, declaratedField.getKey().indexOf(" ")) + "()");
			}
			writer.println(";");
		}

		if (fullInjection) {
			writer.println("");
			writer.println("\t@Override");
			writer.println("\tprotected boolean fullMockInjection() {");
			writer.println("\t\treturn true;");
			writer.println("\t}");
		}

		for (String[] test : generatedTests) {
			writer.println("");
			for (int i = 0; i < test.length; i++) {
				writer.println((i < 2 || i == test.length - 1 ? "\t" : "\t\t") + test[i]);
			}
		}
		writer.print("\n}");
		writer.close();
	}

	@Override
	public void onUsedClass(Class<?> cls, boolean onlyForImport) {
		importedClasses.add(cls);
		if (!onlyForImport) {
			testedClasses.add(cls);
		}
	}

	@Override
	public void onDeclaratedField(String field, String... newAnnotations) {
		Set<String> annotations = declaratedFields.get(field);
		if (annotations == null) {
			annotations = new HashSet<String>();
			declaratedFields.put(field, annotations);
		}
		if (newAnnotations != null) {
			for (String annotation : newAnnotations) {
				annotations.add(annotation);
			}
		}
	}

}
