package com.freeyourcode.testgenerator.logger;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.google.common.base.Preconditions;

public class FileTestLogger extends TestGeneratorLogger {
	
	private static final String GENERATED_FILE_PATH = "file";
	private static final String GENERATED_FILE_PACKAGE = "package";
	private static final String FULL_INJECTION="fullInjection";
	
	private final static Log log = LogFactory.getLog(FileTestLogger.class);
	private final static SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
	
	private final List<String[]> generatedTests = new ArrayList<String[]>();
	private final Set<Class<?>> importedClasses = new HashSet<Class<?>>();
	private final Set<Class<?>> testedClasses = new HashSet<Class<?>>();
	private final Map<String, Set<String>> declaratedFields = new HashMap<String, Set<String>>(); 
	
	public FileTestLogger(Properties props) {
		super(props);
	}

	@Override
	public void onGenerationSuccess(String... codeLines) {
		generatedTests.add(codeLines);
	}

	@Override
	public void onGenerationFail(String msg, Exception e) {
		log.error(msg, e);
		generatedTests.add(new String[]{"//ERROR: Test generation failure caused by error: "+msg});
	}
	
	@Override
	public void startKilling() {
		//TODO Start killing is clearing the logger but we should begin to listen the code only when start has been called to improve
		//performance (stop listening to code when stop is called or if start has never been called).
		generatedTests.clear();
		importedClasses.clear();
		testedClasses.clear();
		declaratedFields.clear();
	}

	@Override
	public void stopKilling() {
		try {
			writeFile();
		} catch (Exception e) {
			log.error(e.getMessage());
			e.printStackTrace();
		}
	}
	
	private void writeFile() throws IOException{
		String filePath = Preconditions.checkNotNull(props.getProperty(GENERATED_FILE_PATH), "Generated file path (tag 'file') is required for a file logger");
		String packageName = Preconditions.checkNotNull(props.getProperty(GENERATED_FILE_PACKAGE), "Generated file package (tag 'package') is required for a file logger");
		boolean fullInjection = Boolean.parseBoolean(props.getProperty(FULL_INJECTION, "false"));
		
		File file = new File(filePath);
		file.delete();
		file.createNewFile();
		String fileName = file.getName();
		String className = fileName.substring(0, fileName.lastIndexOf("."));
		PrintWriter writer = new PrintWriter(filePath, "UTF-8");
		writer.println("package "+packageName+";\n");
		writer.println("import org.mockito.InjectMocks;");
		writer.println("import org.mockito.Mock;");
		writer.println("import org.mockito.Spy;");
		writer.println("import org.mockito.Mockito;");
		writer.println("import org.powermock.api.mockito.PowerMockito;");
		writer.println("import org.powermock.core.classloader.annotations.PrepareForTest;");
		writer.println("import org.testng.annotations.Test;\n");
		writer.println("import com.freeyourcode.test.utils.GeneratedTestCase;");
		writer.println("import com.freeyourcode.prettyjson.JsonSerialisationUtils;");

		for(Class<?> usedClass : importedClasses){
			writer.println("import "+usedClass.getName().replace("$", ".")+";");
		}
		writer.println("");
		writer.println("/**");
		writer.println("* Test generated by a FreeYourCode agent at "+format.format(new Date(System.currentTimeMillis())));
		writer.println("*/");
		writer.print("@PrepareForTest({");
		boolean first = true;
		for(Class<?> usedClass : testedClasses){
			if(!first){
				writer.print(", ");
			}
			else{
				first = false;
			}
			writer.print(usedClass.getSimpleName()+".class");
		}
		writer.println("})");
		writer.println("public class "+className+" extends GeneratedTestCase {");
		writer.println("");
		for(Entry<String, Set<String>> declaratedField : declaratedFields.entrySet()){
			boolean firstAnnotation = true;
			for(String annotation : declaratedField.getValue()){
				writer.print((firstAnnotation ? "\t":" ")+annotation);
				firstAnnotation = false;
			}
			writer.println("");
			writer.print("\tprivate "+declaratedField.getKey());
			if(declaratedField.getValue().contains("@Spy")){
				//TODO c'est idiot de défiare une concaténation déjà faite...
				writer.print(" = new "+declaratedField.getKey().substring(0,declaratedField.getKey().indexOf(" "))+"()");
			}
			writer.println(";");
		}
		
		if(fullInjection){
			writer.println("");
			writer.println("\t@Override");
			writer.println("\tprotected boolean fullMockInjection() {");
			writer.println("\t\treturn true;");
			writer.println("\t}");
		}
		
		for(String[] test : generatedTests){
			writer.println("");
			for(int i = 0; i < test.length; i++){
				writer.println((i < 2 || i == test.length-1 ? "\t":"\t\t")+test[i]); 
			}
		}
		writer.print("\n}");
		writer.close();
	}

	@Override
	public void onUsedClass(Class<?> cls, boolean onlyForImport) {
		importedClasses.add(cls);
		if(!onlyForImport){
			testedClasses.add(cls);
		}
	}

	@Override
	public void onDeclaratedField(String field, String... newAnnotations) {
		Set<String> annotations = declaratedFields.get(field);
		if(annotations == null){
			annotations = new HashSet<String>();
			declaratedFields.put(field, annotations);
		}
		if(newAnnotations != null){
			for(String annotation : newAnnotations){
			annotations.add(annotation);
			}
		}
	}

}
